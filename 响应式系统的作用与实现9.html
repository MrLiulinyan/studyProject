<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>计算属性computed完善</title>
	</head>
	<body>
	</body>
	<script>
		const obj = {
			foo: 1,
			bar: 2
		};
		let activeEffect;
		const effectStack = []
		// proxy代理
		const bucket = new WeakMap();
		// get时触发
		function track(target, key) {
			// 没有副作用函数直接返回值，不需要存储
			if (!activeEffect) return target[key];
			//根据 target 从bucket里取出当前对象的存储信息 depsMap
			let depsMap = bucket.get(target);
			// 如果没有当前对象信息 depsMap 则新建Map并放入bucket中
			if (!depsMap) {
				depsMap = new Map();
				bucket.set(target, depsMap);
			}
			// 根据当前对象的key，从对象信息 depsMap 中获取当前key值的存储信息
			let deps = depsMap.get(key);
			// 如果没有当前key的信息 deps 则新建Set并放入对象存储信息 depsMap中
			if (!deps) {
				deps = new Set();
				depsMap.set(key, deps);
			}
			//将副作用函数放入到 当前key的存储信息deps里
			deps.add(activeEffect);
			activeEffect.deps.push(deps)
		}
		// set时触发
		function trigger(target, key) {
			//根据target 从bucket里获取当前对象的存储信息
			const depsMap = bucket.get(target);
			// 如果存储信息存在，则根据key，从对象信息depsMap里获取当前key的存储信息，并执行存储里的所有副作用函数
			if (depsMap) {
				const effects = depsMap.get(key);
				const effectToRun = new Set();
				// 解决副作用函数无限循环调用问题，如果副作用函数与当前正在执行的副作用函数相同，则不触发执行
				effects && effects.forEach(effect => {
					if (effect !== activeEffect) effectToRun.add(effect);
				})
				effectToRun && effectToRun.forEach(fn => {
					if (fn.options.scheduler) {
						fn.options.scheduler(fn);
					} else {
						fn()
					}
				});
			}
		}

		const data = new Proxy(obj, {
			get(target, key) {
				// 把副作用函数添加到对应的key存储里
				track(target, key)
				return target[key]
			},
			set(target, key, newVal) {
				target[key] = newVal;
				// 把key对应的副作用取出并执行
				trigger(target, key);
				return true
			}
		});
		// 清除当前key存储的所有副作用函数
		function cleanup(effectFn) {
			for (let i = 0; i < effectFn.deps.length; i++) {
				const deps = effectFn.deps[i];
				deps.delete(effectFn)
			}
			effectFn.deps.length = 0;
		}

		// 副作用函数
		function effect(fn, options = {}) {
			const effectFn = () => {
				cleanup(effectFn);
				activeEffect = effectFn;
				effectStack.push(effectFn); // 将副作用函数出入数组
				const res = fn();
				effectStack.pop(); // 将副作用函数从数组中删除
				activeEffect = effectStack[effectStack.length - 1]; // 将当前执行的副作用函数指向上一个副作用函数，从而解决副作用函数嵌套，导致当前副作用函数指向错误问题；
				return res;
			}
			effectFn.deps = [];
			effectFn.options = options; // 增加options
			if (!options.lazy) effectFn(); // lazy为true时不立即执行副作用函数
			return effectFn;
		}

		// 任务队列
		const jobQueue = new Set();
		const p = Promise.resolve();
		let isFlushing = false;

		function flushJob() {
			if (isFlushing) return;
			isFlushing = true;
			p.then(() => {
				jobQueue.forEach(job => job())
			}).finally(() => {
				isFlushing = false;
			})
		}

		// 计算函数
		function computed(getter) {
			let value;
			let dirty = true;
			const effectFn = effect(getter, {
				lazy: true,
				// 增加scheduler调度器，将dirty设置为true
				scheduler() {
					if(!dirty){
					  dirty = true;
					  //当计算属性依赖的响应式数据发生变化时，手动调用trigger函数触发响应
					  trigger(obj,'value');
					}
				}
			});
			const obj = {
				get value() {
					if (dirty) {
						value = effectFn();
						dirty = false;
					}
					// 当读取value时，手动调用track函数进行追踪
					track(obj,'value');
					return value
				}
			};
			return obj
		}

		const sumRes = computed(() => {
			return data.foo + data.bar
		});
        
		effect(()=>{
			console.log(sumRes.value)
		})
		
		data.foo++
	</script>
</html>